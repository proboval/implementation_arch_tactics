AT_ID,Tactic_Name,Primary_QA_Impact,Description,Code_Manifestation,Positive_Impact,Negative_Impact,Related_Terms,Source
AT1,Encapsulate Module,Maintainability (Modifiability, Analyzability),Hide internal details of a module behind a stable interface to localize likely changes.,Clear public API, private fields, access via interfaces or facades only.,Reduces ripple effects of changes, simplifies reasoning about modules.,Extra indirection layer, more boilerplate and interface management.,Information hiding, ADT, module boundary,
AT2,Reduce Module Size,Maintainability (Modifiability, Analyzability),Split large modules into smaller units with limited responsibilities.,Breaking “god classes”, splitting large files into cohesive packages.,Easier understanding, faster change and review cycles.,More modules to navigate, potential overhead in wiring dependencies.,God object removal, micro-modules,
AT3,Increase Semantic Cohesion,Maintainability (Modifiability),Group responsibilities that change for the same reasons into the same module.,Refactoring files so that each handles one business concept or variation.,Aligns structure with change patterns, reduces scattered edits.,Requires domain analysis effort, refactoring cost.,Single Responsibility Principle, feature cohesion,
AT4,Restrict Dependencies,Maintainability (Modifiability),Limit which modules a given module may depend on, enforcing allowed directions.,Layered architecture with allowed imports, dependency rules in build tools.,Reduces uncontrolled coupling and architectural erosion, safer refactoring.,Can be perceived as restrictive, may require extra adaptation layers.,Layering, dependency constraints,
AT5,Use Intermediary,Maintainability (Modifiability, Testability),Introduce an intermediary between components to decouple them.,Message bus, mediator, adapter or façade between services/components.,Enables independent evolution of components, easier replacement.,Added complexity, possible performance overhead.,Mediator, message bus, API gateway,
AT6,Abstract Common Services,Maintainability (Modifiability, Reusability),Factor shared services into reusable abstractions with well‑defined interfaces.,Shared logging, auth, persistence components used via interfaces.,Avoids duplication, centralizes changes to cross‑cutting concerns.,Risk of over‑generalization, can become new “god” components.,Shared services, cross‑cutting concerns,
AT7,Defer Binding (Late Binding),Maintainability (Modifiability, Flexibility),Bind certain decisions (e.g., implementation choice) later in lifecycle or at runtime.,Configuration‑driven implementations, strategy selected via DI container.,Enables change without recompilation, easier product variants.,More complex configuration, harder debugging of runtime decisions.,Dynamic configuration, strategy selection,
AT8,Generalize Module Interface,Maintainability (Modifiability, Reusability),Replace multiple similar interfaces with a more general one to support variations.,Generic repositories, generalized service interfaces for multiple entities.,Simplifies adding new variants, reduces code duplication.,Over‑general interfaces can be hard to understand and specialize.,Generalization, polymorphic interfaces,
AT9,Anticipate Expected Changes,Maintainability (Modifiability),Structure modules around known likely changes identified from scenarios.,Separating UI from domain, plugin points for foreseen extension areas.,Reduces future change cost in high‑volatility areas.,Up‑front design effort, risk of guessing wrong and over‑design.,Change scenarios, variability points,
AT10,Localize Change (Change Locality),Maintainability (Modifiability),Organize modules so that a given change type affects as few modules as possible.,Feature‑oriented packaging, cohesive services aligned with business capabilities.,Minimizes change propagation, simplifies impact analysis.,Requires ongoing discipline; misalignment can accumulate over time.,Change impact control, feature slicing,
AT11,Refactor Continuously,Maintainability (Modifiability, Analyzability),Systematically restructure code without changing externally visible behavior.,Applying extract method, move class, split module, rename refactorings.,Improves structure and readability, slows down architectural erosion.,Short‑term cost, risk if tests are weak.,Code refactoring, technical debt repayment,
AT12,Enforce Layered Architecture,Maintainability (Modifiability, Analyzability),Separate system into layers with controlled, usually downward, dependencies.,Presentation, application, domain, infrastructure layers with strict import rules.,Clarifies responsibilities, simplifies substitution within a layer.,Can be rigid; shortcuts and violations appear if over‑constrained.,Layered style, relaxed layering control,
AT13,Introduce Plugin Extension Points,Maintainability (Modifiability, Extensibility),Provide explicit extension points where new behavior can be added as plugins.,Plugin registries, module discovery, strategy providers loaded at runtime.,New features via new modules without modifying core.,Higher initial complexity, need for versioning and compatibility handling.,Plugin architecture, microkernel,
AT14,Use Dependency Injection,Maintainability (Modifiability, Testability),Invert control of dependencies so modules receive collaborators from outside.,DI containers, constructor injection, interfaces for external services.,Simplifies substitution, mocking, and refactoring of dependencies.,DI frameworks add indirection and learning overhead.,Inversion of Control, IoC container,
AT15,Separate Read and Write Paths,Maintainability (Modifiability, Performance),Split responsibilities for queries and updates into different models or components.,CQRS‑style handlers, separate DTOs for commands and queries.,Clarifies responsibilities and constraints, eases evolution of read/write behavior.,More components and models to maintain, consistency concerns.,CQRS, command–query separation,
AT16,Introduce Facade for Subsystem,Maintainability (Modifiability, Analyzability),Provide a simpler interface over a complex subsystem.,Facade services wrapping complex legacy or third‑party APIs.,Shields clients from internal changes, reduces coupling to internals.,Facade can become bloated; risk of leaking low‑level concepts over time.,Facade pattern, anti‑corruption layer,
AT17,Centralize Configuration,Maintainability (Modifiability, Operability),Externalize and centralize configuration of behavior and dependencies.,Config files, env‑based settings, centralized config service.,Behavior changes via config rather than code, fewer redeploys.,Misconfigured systems, configuration sprawl and validation overhead.,External configuration, twelve‑factor config,
AT18,Introduce Stable Interfaces for External Systems,Maintainability (Modifiability, Portability),Wrap external systems behind stable internal interfaces or anti‑corruption layers.,Adapter services, gateways hiding vendor‑specific APIs from core code.,Limits impact of external changes, simplifies vendor or API migration.,Extra translation code, potential performance cost.,Adapter, anti‑corruption layer,
AT19,Use Semantic Versioning and API Evolution Rules,Maintainability (Modifiability),Define explicit rules for evolving public APIs safely over time.,Versioned endpoints, deprecation policies, backward‑compatible changes.,Reduces breaking changes, eases client migration.,Requires governance and tooling, more versions to support.,API evolution, compatibility management,
AT20,Improve Testability via Test Points,Maintainability (Testability, Modifiability),Design architecture so that components are independently testable through defined seams.,Ports/adapters, hexagonal boundaries, clear interfaces for mocking.,Facilitates regression tests after changes, safer refactoring.,Additional abstraction layers, more interfaces and fixtures.,Testability tactics, hexagonal architecture,